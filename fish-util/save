char *reverse(char *s) {
    int len = strnlen(s, STRNLEN_REVERSE);  // without \0. can still segfault.
    if (len == STRNLEN_REVERSE) {
        warn("reverse(): input too big");
        return NULL;
    }
    char *r = str(len+1);
    int i;
    for (i = 0; i < len; i++) {
        *(r+i) = *(s+len-i-1);
    }
    *(r+i) = '\0';
    return r;
}


// errno doesn't always work.
long int stoie(const char *s, int *err) {
    char *endptr;
    long int i = strtol(s, &endptr, 10);
    // nothing converted
    if (endptr == s) {
        *err = 1;
        return LONG_MIN;
    }
    else {
        return i;
    }
}

long int stoi(const char *s) {
    int err = 0;
    int i = stoie(s, &err);
    if (err) {
        // XX
        warn("Can't convert string to int: %s", R_(s));
        return LONG_MIN;
    }
    return i;
}

